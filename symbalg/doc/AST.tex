% -*- mode: LaTeX; coding: utf-8 -*-
\section{Ввод выражений}
\label{sec:AST}
\subsection{Общие замечания}
Система {\tt SYMBALG} позволяет смешивать инструкции языка \verb'Python', которые будут выполняться непосредственно при запуске программы кодогенерации,
и различные выражения (как правило алгебраические), которые будут преобразованы в AST, при необходимости проанализированы и сконвертированы в соответствующий
выходной формат. Выражения, преобразуемые в AST, вводятся в обычном синтаксисе языка \verb'Python', но их аргументами должны быть 
экземпляры класса \verb'Var' либо функции из словаря \verb'spaceOp' (модуль \verb'expressions.py'). 

Если в выражении хотя бы один из аргументов является экземпляром класса \verb'Var', результатом выполнения выражения будет AST.
Вы можете специально создать необходимые экземпляры класса \verb'Var' в текущем пространстве имен, но как правило для создания AST
используется стандартная функция \verb'eval', вызываемая в специальном контексте. Предполагается, что глобальным пространством имен будет словарь
\verb'spaceOp', содержащий математические функции, функции скобок, и специальный экземпляр класса \verb'EmptyVar' с индентификатором \verb'_',
а локальным пространством имен будет специальный объект пользователя, эмулирующий словарь и создающий экземпляры класса \verb'Var' по правилам пользователя,
зависящим от специфики решаемой задачи.

Все классы, из которых собирается AST, являются наследниками класса \verb'BaseOp'. Для всех объектов перегружены операции,
возвращающие экземпляры соотвествующих классов. Скобки в выражении, используемые для задания приоритета выполнения операций, учитываются при создании AST,
но при конвертации выражения в любой из форматов скобки расставлются лишь при необходимости, согласно приоритету операций.
Перегруженные операции, их приоритет и названия соотвествующих классов, экземпляры которых являются узлами AST, приведены в таблице~\ref{symbalg:op:table}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{|l|l|l|c|c|}
\hline
         & метод          & класс &           &                 \\ 
операция & \verb'BaseOp' & AST   & приоритет & коммутативность \\ 
\hline
$a^b$ & \verb'__pow__' & \verb'PowOp' & 1 & нет \\ 
\hline
$-a$ & \verb'__neg__' & \verb'NegOp' & 2 & --- \\ 
$+a$ & \verb'__pos__' & \verb'PosOp' & 2 & --- \\ 
\verb'~'$a$ & \verb'__inv__' & \verb'InvOp' & 2 & --- \\ 
\hline
$a * b$ & \verb'__mul__' & \verb'MulOp' & 3 & да \\ 
$a/b$ & \verb'__div__' & \verb'DivOp' & 3 & нет \\ 
$a//b$ & \verb'__floordiv__' & \verb'FloordivOp' & 3 & нет \\ 
$a\%b$ & \verb'__mod__' & \verb'ModOp' & 3 & нет \\ 
\hline
$a+b$ & \verb'__add__' & \verb'AddOp' & 4 & да \\ 
$a-b$ & \verb'__sub__' & \verb'SubOp' & 4 & нет \\ 
\hline
$a$\verb'<<'$b$ & \verb'__lshift__' & \verb'LshiftOp' & 5 & нет \\ 
$a$\verb'>>'$b$ & \verb'__rshift__' & \verb'RshiftOp' & 5 & нет \\ 
\hline
$a$\verb'&'$b$ & \verb'__and__' & \verb'AndOp' & 6 & да \\ 
\hline
$a$\verb'|'$b$ & \verb'__or__' & \verb'OrOp' & 7 & да \\ 
\hline
$a$\verb'^'$b$ & \verb'__xor__' & \verb'XorOp' & 8 & да \\ 
\hline
$a=b$ & \verb'__eq__' & \verb'EqOp' & 9 & да \\ 
$a\neq b$ & \verb'__ne__' & \verb'NeOp' & 9 & да \\ 
$a< b$ & \verb'__lt__' & \verb'EqOp' & 9 & нет \\ 
$a\leq b$ & \verb'__le__' & \verb'LeOp' & 9 & нет \\ 
$a> b$ & \verb'__gt__' & \verb'GtOp' & 9 & нет \\ 
$a\geq b$ & \verb'__ge__' & \verb'GeOp' & 9 & нет \\ 
\hline
\end{tabular}
\end{center}
\caption{Таблица перегруженных операций}\label{symbalg:op:table}
\end{table}

При задании выражений категорически {\bf не рекомендуется} явно использовать имена классов реализующих узлы AST, за исключением специально оговоренных случаев 
(например класса \verb'Not' или классов, реализующих скобки), поскольку имена классов могут не присутствовать в контексте выполнения кода.
Имена классов--узлов AST используются для настройки преобразования AST в различные форматы вывода и для анализа введенных выражений.

При задании выражений может использоваться специальный экземпляр класса \verb'EmptyVar' с индентификатором \verb'_', содержащийся в словаре \verb'spaceOp'. 
Фактически, при помощи этого объекта расширяется синтакис \verb'Python'. Вы можете вводить свои операции, как комбинации уже существующих
бинарных операций, разделенных символом \verb'_' (например \verb'a/_/b'). Экземпляр класса \verb'EmptyVar' не может быть приведен к строке и не 
может присутствовать в итоговом выражении в формате AST. 

При задании участков кода для \verb'C++' некоторые конструкции не могут быть заданы из \verb'Python' непосредственно. Например, код вида \verb'p->a' или
\verb'&(A::x)' может быть сформирован лишь в виде строки, что исключает возможность анализа кода. Для подобных ситуаций специально введен класс \verb'JoinOp',
позволяющий вводить в перемешку участки кода в виде AST и в виде строк. При ковертации, все участки сливаются без разделяющих пробелов.  Например, код
\begin{verbatim}
    aiv::indx<3>(a->x)
\end{verbatim}
может быть сформирован как
\begin{verbatim}
    JoinOp('aiv::indx<3>(', a, '->', x, ')')
\end{verbatim}
Непосредственное обращение к классу \verb'JoinOp' выглядит довольно громоздко, кроме того этот класс не пристутсвует в словаре \verb'spaceOp'. 
Во всех случаях рекомендуется более лаконичная запись
\begin{verbatim}
    _['aiv::indx<3>(', a, '->', x, ')']
\end{verbatim}
которая к тому же может использоваться при присваивании (слева от знака равенства) при задании участков графа зависмости численных схем.

\subsection{Математические функции}
В словаре \verb'spaceOp' представлены математические функции, присутствующие в модуле \verb'math.py' и заголовочном файле \verb'math.h':
\begin{verbatim}
    acos acosh asin asinh atan atanh cos cosh 
    exp fabs floor log log10 sin sinh sqrt tan tanh
\end{verbatim}
Математические функции являются наследниками класса \verb'UnaryOp' с приоритетом 0. Математические функции корректно конвертируются в формат \LaTeX, в частности 
для них корректно проставляются степени, например код \verb'cos(x)**2' при выовде в \LaTeX будет преобразован в $\cos^2 x$. 


\subsection{Явное задание скобок}
Для явного задания скобок могут использоваться специальные классы скобок из словаря \verb'spaceOp', хотя в ряде случаев
более лаконичным (наглядным) может оказаться вызов метода \verb'_.__call__', см. таблицу~\ref{symbalg:brakets:table}. 
Все скобки преобразуются к обычным (круглым) скобкам при конвертации в \verb'C++'/\verb'Python', и в соотвествующие скобки при конвертации
в обычный текст или \LaTeX.

\begin{table}
\begin{tabular}{|r|l|l|l|l|l|}
\hline
скобки                & \verb'(...)'   & \verb'[...]'       & \verb'{...}'      & \verb'|...|'          & \verb'<...>'   \\
класс AST             & \verb'crc_bk'  & \verb'rm_bk'       & \verb'fig_bk'     & \verb'fabs'           &  \verb'ang_bk' \\
вызов через объект \verb'_'  & \verb'_(...)'  & \verb'_(..., [])' & \verb'_(..., {})' & \verb'_(..., "||")'  & \verb'_(..., "<>")'  \\
расширенный синтаксис & \verb'(%...%)' & \verb'[%...%]'    & \verb'{%...%}'     & \verb'|%...%|'        & \verb'<%...%>' \\
\hline
\end{tabular}
\caption{Виды скобок. Последняя строка может исполььзоваться лишь при обработке функцией {\tt expressions.parse\_bk}}\label{symbalg:brakets:table}
\end{table}



\subsection{Условия и логические операции and, or и not}
Поскольку разбор выражения в AST реализован на основе перегрузки операций, в выражении не могут непосредственно применяться логические операции 
\verb'and', \verb'or', \verb'not' и тернарный оператор \verb'... if ... else ...', поскольку их перегрузка невозможна.
Кроме того, эти операции актуальны в неперегруженном виде при задании выражений, например в зависимости от значений флага может выбираться тот или иной 
вид численной схемы еще на этапе генерации кода. 

Для задания унарного оператора \verb'not' используется класс \verb'Not' из словаря \verb'spaceOp' (например \verb'Not(a<b)'), корректно конвертирующийся 
в форматы языков \verb'Python' (как \verb'not ...') и \verb'C++' (как \verb'!...').

Для задания операторов \verb'and' и \verb'or' используются методы \verb'.And(...)' и \verb'.Or(...)' базвого класса \verb'BaseOp' 
или операторы \verb'&_&' и \verb'|_|'. При их вызове возвращаются экземпляры классов \verb'BoolAndOp' и \verb'BoolOrOp', реализующие
узлы AST для соотвествующих операций. Поскольку приоритеты  операций \verb'|' и \verb'&' выше приоритета операций сравнения, при использовании 
записи  \verb'&_&' и \verb'|_|' желательно использовать скобки, например для задания выражения 
\begin{verbatim}
    a>b and c==d
\end{verbatim}
код
\begin{verbatim}
    (a>b).And(c==d)
\end{verbatim}
или
\begin{verbatim}
    (a>b)&_&(c==d)    
\end{verbatim}
корректен, и приводит к нужным результатам, а код 
\begin{verbatim}
    a>b &_& c==d   
\end{verbatim}
будет эквивалентен выражению \verb'a>(b and c)==d'.

Для задания тернарных операторов \verb'... if ... else ...' в выражении используется специальная функция \verb'ifch' из словаря \verb'spaceOp'. 
Функция может принимать три аргумента, в этом случае возвращается экземпляр класса \verb'IfElseOp' (как узел AST), либо два аругмента, в этом случае
возвращается спецальная функция, запоминающая введенные аргументы и готовая опять к приему двух или трех аргументов. Узел AST генерируется лишь при передаче 
трех аргументов. Например выражение
\begin{verbatim}
    a if a<b else b if b<c else c if c>d else d
\end{verbatim}
может быть задано как
\begin{verbatim}
    ifch(a, a<b)(b, b<c)(c, c>d, d)
\end{verbatim}

\subsection{Задание индексов, операций вызова и доступа к атрибуту} 
Для использования в выражениях конструкиций типа \verb"a[1,2]", \verb"b(d,1)" и \verb"g.h" на основе бинарных операций были реализованы следующие классы:
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Класс & Описание & Пример\\
\hline
 \verb"IndexOp(BinaryOp)" & Квадратные скобки.  & \verb"a[1,2]" \\
 
 \verb"CallOp(BinaryOp)" &  Круглые скобки.  &\verb"b(d,1)" \\
 
 \verb"AttrOp(BinaryOp)" &  Оператор точки & \verb"g.h"\\
\hline
\end{tabular}
\end{center}
С помощью \verb"IndexOp" можно указывать индексы. 
С помощью \verb"CallOp" можно имитировать операцию вызова с аргументами или без.
С помощью \verb"AttrOp" можно имитировать операцию доступа к атрибуту.