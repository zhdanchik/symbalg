import sys; sys.setdlopenflags(0x00100|sys.getdlopenflags())
import sys; sys.setdlopenflags(0x00100|sys.getdlopenflags())
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_model', [dirname(__file__)])
        except ImportError:
            import _model
            return _model
        if fp is not None:
            try:
                _mod = imp.load_module('_model', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _model = swig_import_helper()
    del swig_import_helper
else:
    import _model
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _setstate( self, state ):
    if not hasattr( self, 'this' ) : self.__init__()
    self.__C_setstate__(state)
def import_aivlib(tgt) :
    name = tgt.split('-')[0]
    try : exec('import aivlib.'+name)
    except ImportError, e : import os; os.system('make-aivlib %r'%tgt); exec('import aivlib.'+name)
    return eval('aivlib.'+name)
def _swig_setattr(self,class_type,name,value):
    if name in class_type.__swig_setmethods__ : value = getattr( self, name ).__class__(value)
    return _swig_setattr_nondynamic(self,class_type,name,value,0)
__makefile__='model.mk'

class aiv_convert_for_compare_float(_object):
    """Proxy of C++ std::aiv_convert_for_compare_float class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, aiv_convert_for_compare_float, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, aiv_convert_for_compare_float, name)
    __repr__ = _swig_repr
    __swig_setmethods__["flt"] = _model.aiv_convert_for_compare_float_flt_set
    __swig_getmethods__["flt"] = _model.aiv_convert_for_compare_float_flt_get
    if _newclass:flt = _swig_property(_model.aiv_convert_for_compare_float_flt_get, _model.aiv_convert_for_compare_float_flt_set)
    __swig_setmethods__["fix"] = _model.aiv_convert_for_compare_float_fix_set
    __swig_getmethods__["fix"] = _model.aiv_convert_for_compare_float_fix_get
    if _newclass:fix = _swig_property(_model.aiv_convert_for_compare_float_fix_get, _model.aiv_convert_for_compare_float_fix_set)
    def __init__(self): 
        """__init__(std::aiv_convert_for_compare_float self) -> aiv_convert_for_compare_float"""
        this = _model.new_aiv_convert_for_compare_float()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_aiv_convert_for_compare_float
    __del__ = lambda self : None;
aiv_convert_for_compare_float_swigregister = _model.aiv_convert_for_compare_float_swigregister
aiv_convert_for_compare_float_swigregister(aiv_convert_for_compare_float)

class _base_mem(_object):
    """Proxy of C++ aiv::_base_mem class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _base_mem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _base_mem, name)
    __repr__ = _swig_repr
    __swig_getmethods__["D"] = _model._base_mem_D_get
    if _newclass:D = _swig_property(_model._base_mem_D_get)
    __swig_getmethods__["szT"] = _model._base_mem_szT_get
    if _newclass:szT = _swig_property(_model._base_mem_szT_get)
    __swig_setmethods__["N"] = _model._base_mem_N_set
    __swig_getmethods__["N"] = _model._base_mem_N_get
    if _newclass:N = _swig_property(_model._base_mem_N_get, _model._base_mem_N_set)
    __swig_setmethods__["owners"] = _model._base_mem_owners_set
    __swig_getmethods__["owners"] = _model._base_mem_owners_get
    if _newclass:owners = _swig_property(_model._base_mem_owners_get, _model._base_mem_owners_set)
    def __init__(self, *args): 
        """__init__(aiv::_base_mem self, int AszT, int AD, int * AN) -> _base_mem"""
        this = _model.new__base_mem(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete__base_mem
    __del__ = lambda self : None;
    def len(self):
        """len(_base_mem self) -> size_t"""
        return _model._base_mem_len(self)

_base_mem_swigregister = _model._base_mem_swigregister
_base_mem_swigregister(_base_mem)

class arr_head(_object):
    """Proxy of C++ aiv::arr_head class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, arr_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, arr_head, name)
    __repr__ = _swig_repr
    __swig_getmethods__["D"] = _model.arr_head_D_get
    if _newclass:D = _swig_property(_model.arr_head_D_get)
    __swig_getmethods__["szT"] = _model.arr_head_szT_get
    if _newclass:szT = _swig_property(_model.arr_head_szT_get)
    __swig_getmethods__["N"] = _model.arr_head_N_get
    if _newclass:N = _swig_property(_model.arr_head_N_get)
    def load(self, *args):
        """load(arr_head self, aiv::Istream & S)"""
        return _model.arr_head_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::arr_head self) -> arr_head
        __init__(aiv::arr_head self, aiv::Istream & S) -> arr_head
        __init__(aiv::arr_head self, arr_head H) -> arr_head
        """
        this = _model.new_arr_head(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_arr_head
    __del__ = lambda self : None;
arr_head_swigregister = _model.arr_head_swigregister
arr_head_swigregister(arr_head)

class lrc_head(_object):
    """Proxy of C++ aiv::lrc_head class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, lrc_head, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, lrc_head, name)
    __repr__ = _swig_repr
    __swig_getmethods__["D"] = _model.lrc_head_D_get
    if _newclass:D = _swig_property(_model.lrc_head_D_get)
    __swig_getmethods__["D2"] = _model.lrc_head_D2_get
    if _newclass:D2 = _swig_property(_model.lrc_head_D2_get)
    __swig_getmethods__["szT"] = _model.lrc_head_szT_get
    if _newclass:szT = _swig_property(_model.lrc_head_szT_get)
    __swig_getmethods__["R"] = _model.lrc_head_R_get
    if _newclass:R = _swig_property(_model.lrc_head_R_get)
    __swig_getmethods__["N"] = _model.lrc_head_N_get
    if _newclass:N = _swig_property(_model.lrc_head_N_get)
    __swig_destroy__ = _model.delete_lrc_head
    __del__ = lambda self : None;
    def load(self, *args):
        """load(lrc_head self, aiv::Istream & S)"""
        return _model.lrc_head_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::lrc_head self) -> lrc_head
        __init__(aiv::lrc_head self, aiv::Istream & S) -> lrc_head
        __init__(aiv::lrc_head self, lrc_head H) -> lrc_head
        """
        this = _model.new_lrc_head(*args)
        try: self.this.append(this)
        except: self.this = this
lrc_head_swigregister = _model.lrc_head_swigregister
lrc_head_swigregister(lrc_head)

class base_sphere(_object):
    """Proxy of C++ aiv::base_sphere class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_sphere, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, base_sphere, name)
    __repr__ = _swig_repr
    __swig_getmethods__["R"] = _model.base_sphere_R_get
    if _newclass:R = _swig_property(_model.base_sphere_R_get)
    __swig_getmethods__["N"] = _model.base_sphere_N_get
    if _newclass:N = _swig_property(_model.base_sphere_N_get)
    def get_ref_count(self):
        """get_ref_count(base_sphere self) -> int"""
        return _model.base_sphere_get_ref_count(self)

    def __init__(self, *args): 
        """
        __init__(aiv::base_sphere self, int AR=-1) -> base_sphere
        __init__(aiv::base_sphere self) -> base_sphere
        __init__(aiv::base_sphere self, base_sphere S) -> base_sphere
        """
        this = _model.new_base_sphere(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_base_sphere
    __del__ = lambda self : None;
    def init(self, *args):
        """init(base_sphere self, int AR)"""
        return _model.base_sphere_init(self, *args)

    def get_cell_id(self, *args):
        """get_cell_id(base_sphere self, vctr3 r) -> int"""
        return _model.base_sphere_get_cell_id(self, *args)

    def get_cell_vertex(self, *args):
        """get_cell_vertex(base_sphere self, int cid) -> indx3"""
        return _model.base_sphere_get_cell_vertex(self, *args)

    def get_vertex(self, *args):
        """get_vertex(base_sphere self, int vid) -> vctr3"""
        return _model.base_sphere_get_vertex(self, *args)

    def get_cell_neighbours(self, *args):
        """get_cell_neighbours(base_sphere self, int cid) -> indx3"""
        return _model.base_sphere_get_cell_neighbours(self, *args)

    def get_vertex_cells(self, *args):
        """get_vertex_cells(base_sphere self, int vid) -> aiv::indx< 6 > const &"""
        return _model.base_sphere_get_vertex_cells(self, *args)

    def get_cell_area(self, *args):
        """get_cell_area(base_sphere self, int cid) -> double"""
        return _model.base_sphere_get_cell_area(self, *args)

    def get_coord(self, *args):
        """get_coord(base_sphere self, vctr3 x, long i, int AR)"""
        return _model.base_sphere_get_coord(self, *args)

    def get_nb(self, *args):
        """get_nb(base_sphere self, long * nb, long i, int AR)"""
        return _model.base_sphere_get_nb(self, *args)

    def get_cell_center(self, *args):
        """
        get_cell_center(base_sphere self, int cid) -> vctr3
        get_cell_center(base_sphere self, long cid, int AR) -> vctr3
        """
        return _model.base_sphere_get_cell_center(self, *args)

base_sphere_swigregister = _model.base_sphere_swigregister
base_sphere_swigregister(base_sphere)
cvar = _model.cvar
MAX_RANK = cvar.MAX_RANK


def barecentr(*args):
  """barecentr(vctr3 x, vctr3 r) -> vctr3"""
  return _model.barecentr(*args)
class Base_cell(_object):
    """Proxy of C++ Base_cell class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base_cell, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base_cell, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(Base_cell self) -> Base_cell"""
        this = _model.new_Base_cell()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_Base_cell
    __del__ = lambda self : None;
Base_cell_swigregister = _model.Base_cell_swigregister
Base_cell_swigregister(Base_cell)

class cell0(Base_cell):
    """Proxy of C++ cell0 class"""
    __swig_setmethods__ = {}
    for _s in [Base_cell]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cell0, name, value)
    __swig_getmethods__ = {}
    for _s in [Base_cell]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, cell0, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m"] = _model.cell0_m_set
    __swig_getmethods__["m"] = _model.cell0_m_get
    if _newclass:m = _swig_property(_model.cell0_m_get, _model.cell0_m_set)
    __swig_setmethods__["H"] = _model.cell0_H_set
    __swig_getmethods__["H"] = _model.cell0_H_get
    if _newclass:H = _swig_property(_model.cell0_H_get, _model.cell0_H_set)
    def __init__(self): 
        """__init__(cell0 self) -> cell0"""
        this = _model.new_cell0()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_cell0
    __del__ = lambda self : None;
cell0_swigregister = _model.cell0_swigregister
cell0_swigregister(cell0)

class cell1(Base_cell):
    """Proxy of C++ cell1 class"""
    __swig_setmethods__ = {}
    for _s in [Base_cell]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, cell1, name, value)
    __swig_getmethods__ = {}
    for _s in [Base_cell]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, cell1, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m"] = _model.cell1_m_set
    __swig_getmethods__["m"] = _model.cell1_m_get
    if _newclass:m = _swig_property(_model.cell1_m_get, _model.cell1_m_set)
    __swig_setmethods__["m1"] = _model.cell1_m1_set
    __swig_getmethods__["m1"] = _model.cell1_m1_get
    if _newclass:m1 = _swig_property(_model.cell1_m1_get, _model.cell1_m1_set)
    __swig_setmethods__["H"] = _model.cell1_H_set
    __swig_getmethods__["H"] = _model.cell1_H_get
    if _newclass:H = _swig_property(_model.cell1_H_get, _model.cell1_H_set)
    __swig_setmethods__["H1"] = _model.cell1_H1_set
    __swig_getmethods__["H1"] = _model.cell1_H1_get
    if _newclass:H1 = _swig_property(_model.cell1_H1_get, _model.cell1_H1_set)
    def __init__(self): 
        """__init__(cell1 self) -> cell1"""
        this = _model.new_cell1()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_cell1
    __del__ = lambda self : None;
cell1_swigregister = _model.cell1_swigregister
cell1_swigregister(cell1)

class Base_tile(_object):
    """Proxy of C++ Base_tile class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base_tile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base_tile, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["tile_data"] = _model.Base_tile_tile_data_set
    __swig_getmethods__["tile_data"] = _model.Base_tile_tile_data_get
    if _newclass:tile_data = _swig_property(_model.Base_tile_tile_data_get, _model.Base_tile_tile_data_set)
    def start(self):
        """start(Base_tile self)"""
        return _model.Base_tile_start(self)

    def step_H(self, *args):
        """
        step_H(Base_tile self, Base_tile mmm, Base_tile zmm, Base_tile pmm, Base_tile mzm, Base_tile zzm, Base_tile pzm, 
            Base_tile mpm, Base_tile zpm, Base_tile ppm, Base_tile mmz, Base_tile zmz, 
            Base_tile pmz, Base_tile mzz, Base_tile zzz, Base_tile pzz, Base_tile mpz, 
            Base_tile zpz, Base_tile ppz, Base_tile mmp, Base_tile zmp, Base_tile pmp, 
            Base_tile mzp, Base_tile zzp, Base_tile pzp, Base_tile mpp, Base_tile zpp, 
            Base_tile ppp)
        """
        return _model.Base_tile_step_H(self, *args)

    def step_m(self):
        """step_m(Base_tile self)"""
        return _model.Base_tile_step_m(self)

    __swig_destroy__ = _model.delete_Base_tile
    __del__ = lambda self : None;
Base_tile_swigregister = _model.Base_tile_swigregister
Base_tile_swigregister(Base_tile)

class tile0(Base_tile):
    """Proxy of C++ tile0 class"""
    __swig_setmethods__ = {}
    for _s in [Base_tile]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile0, name, value)
    __swig_getmethods__ = {}
    for _s in [Base_tile]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile0, name)
    __repr__ = _swig_repr
    def start(self):
        """start(tile0 self)"""
        return _model.tile0_start(self)

    def step_H(self, *args):
        """
        step_H(tile0 self, Base_tile mmm, Base_tile zmm, Base_tile pmm, Base_tile mzm, Base_tile zzm, Base_tile pzm, 
            Base_tile mpm, Base_tile zpm, Base_tile ppm, Base_tile mmz, Base_tile zmz, 
            Base_tile pmz, Base_tile mzz, Base_tile zzz, Base_tile pzz, Base_tile mpz, 
            Base_tile zpz, Base_tile ppz, Base_tile mmp, Base_tile zmp, Base_tile pmp, 
            Base_tile mzp, Base_tile zzp, Base_tile pzp, Base_tile mpp, Base_tile zpp, 
            Base_tile ppp)
        """
        return _model.tile0_step_H(self, *args)

    def step_m(self):
        """step_m(tile0 self)"""
        return _model.tile0_step_m(self)

    def __init__(self): 
        """__init__(tile0 self) -> tile0"""
        this = _model.new_tile0()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_tile0
    __del__ = lambda self : None;
tile0_swigregister = _model.tile0_swigregister
tile0_swigregister(tile0)

class tile1(Base_tile):
    """Proxy of C++ tile1 class"""
    __swig_setmethods__ = {}
    for _s in [Base_tile]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile1, name, value)
    __swig_getmethods__ = {}
    for _s in [Base_tile]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile1, name)
    __repr__ = _swig_repr
    def start(self):
        """start(tile1 self)"""
        return _model.tile1_start(self)

    def step_H(self, *args):
        """
        step_H(tile1 self, Base_tile mmm, Base_tile zmm, Base_tile pmm, Base_tile mzm, Base_tile zzm, Base_tile pzm, 
            Base_tile mpm, Base_tile zpm, Base_tile ppm, Base_tile mmz, Base_tile zmz, 
            Base_tile pmz, Base_tile mzz, Base_tile zzz, Base_tile pzz, Base_tile mpz, 
            Base_tile zpz, Base_tile ppz, Base_tile mmp, Base_tile zmp, Base_tile pmp, 
            Base_tile mzp, Base_tile zzp, Base_tile pzp, Base_tile mpp, Base_tile zpp, 
            Base_tile ppp)
        """
        return _model.tile1_step_H(self, *args)

    def step_m(self):
        """step_m(tile1 self)"""
        return _model.tile1_step_m(self)

    def __init__(self): 
        """__init__(tile1 self) -> tile1"""
        this = _model.new_tile1()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_tile1
    __del__ = lambda self : None;
tile1_swigregister = _model.tile1_swigregister
tile1_swigregister(tile1)

class tile2(Base_tile):
    """Proxy of C++ tile2 class"""
    __swig_setmethods__ = {}
    for _s in [Base_tile]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile2, name, value)
    __swig_getmethods__ = {}
    for _s in [Base_tile]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile2, name)
    __repr__ = _swig_repr
    def start(self):
        """start(tile2 self)"""
        return _model.tile2_start(self)

    def step_H(self, *args):
        """
        step_H(tile2 self, Base_tile mmm, Base_tile zmm, Base_tile pmm, Base_tile mzm, Base_tile zzm, Base_tile pzm, 
            Base_tile mpm, Base_tile zpm, Base_tile ppm, Base_tile mmz, Base_tile zmz, 
            Base_tile pmz, Base_tile mzz, Base_tile zzz, Base_tile pzz, Base_tile mpz, 
            Base_tile zpz, Base_tile ppz, Base_tile mmp, Base_tile zmp, Base_tile pmp, 
            Base_tile mzp, Base_tile zzp, Base_tile pzp, Base_tile mpp, Base_tile zpp, 
            Base_tile ppp)
        """
        return _model.tile2_step_H(self, *args)

    def step_m(self):
        """step_m(tile2 self)"""
        return _model.tile2_step_m(self)

    def __init__(self): 
        """__init__(tile2 self) -> tile2"""
        this = _model.new_tile2()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _model.delete_tile2
    __del__ = lambda self : None;
tile2_swigregister = _model.tile2_swigregister
tile2_swigregister(tile2)

class indx1(_object):
    """Proxy of C++ aiv::indx<(1)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, indx1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, indx1, name)
    def volume(self):
        """volume(indx1 self) -> long"""
        return _model.indx1_volume(self)

    def __lt__(self, *args):
        """
        __lt__(indx1 self, indx1 r) -> bool
        __lt__(indx1 self, PyObject * t) -> bool
        __lt__(indx1 self, long i) -> bool
        """
        return _model.indx1___lt__(self, *args)

    def __le__(self, *args):
        """
        __le__(indx1 self, indx1 r) -> bool
        __le__(indx1 self, PyObject * t) -> bool
        __le__(indx1 self, long i) -> bool
        """
        return _model.indx1___le__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(indx1 self, indx1 r) -> bool
        __gt__(indx1 self, PyObject * t) -> bool
        __gt__(indx1 self, long i) -> bool
        """
        return _model.indx1___gt__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(indx1 self, indx1 r) -> bool
        __ge__(indx1 self, PyObject * t) -> bool
        __ge__(indx1 self, long i) -> bool
        """
        return _model.indx1___ge__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(indx1 self, indx1 r) -> bool
        __eq__(indx1 self, PyObject * t) -> bool
        __eq__(indx1 self, long i) -> bool
        """
        return _model.indx1___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(indx1 self, indx1 r) -> bool
        __ne__(indx1 self, PyObject * t) -> bool
        __ne__(indx1 self, long i) -> bool
        """
        return _model.indx1___ne__(self, *args)

    def __add__(self, *args):
        """
        __add__(indx1 self, indx1 r) -> indx1
        __add__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(indx1 self, indx1 r) -> indx1
        __sub__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___sub__(self, *args)

    def __xor__(self, *args):
        """
        __xor__(indx1 self, indx1 r) -> indx1
        __xor__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___xor__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(indx1 self, indx1 r) -> long
        __mul__(indx1 self, int j) -> indx1
        """
        return _model.indx1___mul__(self, *args)

    def __imul__(self, *args):
        """__imul__(indx1 self, int j) -> indx1"""
        return _model.indx1___imul__(self, *args)

    def __neg__(self):
        """__neg__(indx1 self) -> indx1"""
        return _model.indx1___neg__(self)

    def __ixor__(self, *args):
        """
        __ixor__(indx1 self, indx1 r) -> indx1
        __ixor__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___ixor__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(indx1 self, indx1 r) -> indx1
        __iadd__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(indx1 self, indx1 r) -> indx1
        __isub__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___isub__(self, *args)

    def __lshift__(self, *args):
        """
        __lshift__(indx1 self, indx1 b) -> indx1
        __lshift__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___lshift__(self, *args)

    def __rshift__(self, *args):
        """
        __rshift__(indx1 self, indx1 b) -> indx1
        __rshift__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___rshift__(self, *args)

    def __ilshift__(self, *args):
        """
        __ilshift__(indx1 self, indx1 b) -> indx1
        __ilshift__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___ilshift__(self, *args)

    def __irshift__(self, *args):
        """
        __irshift__(indx1 self, indx1 b) -> indx1
        __irshift__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___irshift__(self, *args)

    def __mod__(self, *args):
        """
        __mod__(indx1 self, indx1 b) -> indx1
        __mod__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___mod__(self, *args)

    def __imod__(self, *args):
        """
        __imod__(indx1 self, indx1 b) -> indx1
        __imod__(indx1 self, PyObject * t) -> indx1
        """
        return _model.indx1___imod__(self, *args)

    def __rmod__(self, *args):
        """__rmod__(indx1 self, long x) -> indx1"""
        return _model.indx1___rmod__(self, *args)

    def __div__(self, *args):
        """
        __div__(indx1 self, indx1 b) -> indx1
        __div__(indx1 self, PyObject * t) -> indx1
        __div__(indx1 self, int x) -> indx1
        """
        return _model.indx1___div__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(indx1 self, indx1 b) -> indx1
        __idiv__(indx1 self, PyObject * t) -> indx1
        __idiv__(indx1 self, int x) -> indx1
        """
        return _model.indx1___idiv__(self, *args)

    def circ(self, *args):
        """circ(indx1 self, int l) -> indx1"""
        return _model.indx1_circ(self, *args)

    def c_str(self, separator=" ", format="%i"):
        """
        c_str(indx1 self, char const * separator=" ", char const * format="%i") -> char const
        c_str(indx1 self, char const * separator=" ") -> char const
        c_str(indx1 self) -> char const *
        """
        return _model.indx1_c_str(self, separator, format)

    def __contains__(self, *args):
        """__contains__(indx1 self, indx1 I) -> bool"""
        return _model.indx1___contains__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(indx1 self, int x) -> indx1"""
        return _model.indx1___rmul__(self, *args)

    def __len__(self):
        """__len__(indx1 self) -> int const"""
        return _model.indx1___len__(self)

    def __int__(self):
        """__int__(indx1 self) -> long"""
        return _model.indx1___int__(self)

    def __getitem__(self, *args):
        """__getitem__(indx1 self, int i) -> int"""
        return _model.indx1___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(indx1 self, int i, int x)"""
        return _model.indx1___setitem__(self, *args)

    def __getslice__(self, *args):
        """__getslice__(indx1 self, long a, long b) -> PyObject *"""
        return _model.indx1___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(indx1 self, long a, long b, PyObject * t)"""
        return _model.indx1___setslice__(self, *args)

    def __str__(self):
        """__str__(indx1 self) -> PyObject *"""
        return _model.indx1___str__(self)

    def __repr__(self):
        """__repr__(indx1 self) -> PyObject *"""
        return _model.indx1___repr__(self)

    def __getstate__(self):
        """__getstate__(indx1 self) -> PyObject *"""
        return _model.indx1___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(indx1 self, PyObject * t)"""
        return _model.indx1___C_setstate__(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::indx<(1)> self, int val=0) -> indx1
        __init__(aiv::indx<(1)> self) -> indx1
        __init__(aiv::indx<(1)> self, int const * Ap) -> indx1
        __init__(aiv::indx<(1)> self, PyObject * t) -> indx1
        """
        this = _model.new_indx1(*args)
        try: self.this.append(this)
        except: self.this = this
    def __hash__(self):
        """__hash__(indx1 self) -> long"""
        return _model.indx1___hash__(self)

    def py_debug_info(self, *args):
        """py_debug_info(indx1 self, aiv::debug_info & S)"""
        return _model.indx1_py_debug_info(self, *args)

    def less(self, *args):
        """
        less(indx1 self, indx1 N) -> bool
        less(indx1 self, indx1 N, int const seq) -> bool
        """
        return _model.indx1_less(self, *args)

    def next(self, *args):
        """
        next(indx1 self, indx1 finish) -> bool
        next(indx1 self, indx1 start, indx1 finish) -> bool
        next(indx1 self, indx1 start, indx1 finish, int const seq, int const direct=0) -> bool
        next(indx1 self, indx1 start, indx1 finish, int const seq) -> bool
        next(indx1 self, indx1 finish, int const seq, int const direct=0) -> bool
        next(indx1 self, indx1 finish, int const seq) -> bool
        """
        return _model.indx1_next(self, *args)

    def z_next(self, *args):
        """
        z_next(indx1 self, int const rank) -> bool
        z_next(indx1 self, int const rank, int const seq) -> bool
        """
        return _model.indx1_z_next(self, *args)

    __swig_destroy__ = _model.delete_indx1
    __del__ = lambda self : None;
indx1_swigregister = _model.indx1_swigregister
indx1_swigregister(indx1)

def Indx( *L ) : v = getattr( import_aivlib( 'indx%i'%len(L) ), 'indx%i'%len(L) )(); v[:] = tuple(L); return v
indx1.__rcmp__=lambda a,b : -b.__cmp__(a) 
def _indx1__xor__( a,b ) :  
  try : return Indx(*map( int.__mul__, tuple(a),tuple(b) ) )  
  except : return  Indx(*(tuple(a)[:b]+tuple(a)[b+1:]))
indx1.__xor__ = _indx1__xor__ 
indx1.__or__ =lambda a,b : Indx(*(tuple(a)+tuple(((b,),b)[b.__class__.__name__.startswith('indx')])))  
indx1.__ror__=lambda a,b : Indx(*(tuple(((b,),b)[b.__class__.__name__.startswith('indx')])+tuple(a)))  
indx1.__setstate__ = _setstate 

class vctr1(_object):
    """Proxy of C++ aiv::vctr<(1,double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vctr1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vctr1, name)
    def __lt__(self, *args):
        """
        __lt__(vctr1 self, vctr1 r) -> bool
        __lt__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___lt__(self, *args)

    def __le__(self, *args):
        """
        __le__(vctr1 self, vctr1 r) -> bool
        __le__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___le__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(vctr1 self, vctr1 r) -> bool
        __gt__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___gt__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(vctr1 self, vctr1 r) -> bool
        __ge__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___ge__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(vctr1 self, vctr1 r) -> bool
        __eq__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(vctr1 self, vctr1 r) -> bool
        __ne__(vctr1 self, PyObject * t) -> bool
        """
        return _model.vctr1___ne__(self, *args)

    def __and__(self, *args):
        """
        __and__(vctr1 self, vctr1 r) -> double
        __and__(vctr1 self, PyObject * t) -> double
        """
        return _model.vctr1___and__(self, *args)

    def __add__(self, *args):
        """
        __add__(vctr1 self, vctr1 r) -> vctr1
        __add__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(vctr1 self, vctr1 r) -> vctr1
        __sub__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___sub__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(vctr1 self, vctr1 r) -> vctr1
        __iadd__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(vctr1 self, vctr1 r) -> vctr1
        __isub__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___isub__(self, *args)

    def __lshift__(self, *args):
        """
        __lshift__(vctr1 self, vctr1 r) -> vctr1
        __lshift__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___lshift__(self, *args)

    def __rshift__(self, *args):
        """
        __rshift__(vctr1 self, vctr1 r) -> vctr1
        __rshift__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___rshift__(self, *args)

    def __ilshift__(self, *args):
        """
        __ilshift__(vctr1 self, vctr1 r) -> vctr1
        __ilshift__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___ilshift__(self, *args)

    def __irshift__(self, *args):
        """
        __irshift__(vctr1 self, vctr1 r) -> vctr1
        __irshift__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___irshift__(self, *args)

    def __xor__(self, *args):
        """
        __xor__(vctr1 self, vctr1 r) -> vctr1
        __xor__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___xor__(self, *args)

    def __ixor__(self, *args):
        """
        __ixor__(vctr1 self, vctr1 r) -> vctr1
        __ixor__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___ixor__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(vctr1 self, vctr1 r) -> double
        __mul__(vctr1 self, indx1 I) -> vctr1
        __mul__(vctr1 self, PyObject * t) -> vctr1
        __mul__(vctr1 self, double x) -> vctr1
        """
        return _model.vctr1___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(vctr1 self, indx1 I) -> vctr1
        __imul__(vctr1 self, PyObject * t) -> vctr1
        __imul__(vctr1 self, double x) -> vctr1
        """
        return _model.vctr1___imul__(self, *args)

    def __div__(self, *args):
        """
        __div__(vctr1 self, vctr1 r) -> indx1
        __div__(vctr1 self, indx1 I) -> vctr1
        __div__(vctr1 self, PyObject * t) -> vctr1
        __div__(vctr1 self, double x) -> vctr1
        """
        return _model.vctr1___div__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(vctr1 self, indx1 I) -> vctr1
        __idiv__(vctr1 self, PyObject * t) -> vctr1
        __idiv__(vctr1 self, double x) -> vctr1
        """
        return _model.vctr1___idiv__(self, *args)

    def __neg__(self):
        """__neg__(vctr1 self) -> vctr1"""
        return _model.vctr1___neg__(self)

    def abs(self):
        """abs(vctr1 self) -> double"""
        return _model.vctr1_abs(self)

    def pow(self, *args):
        """
        pow(vctr1 self, int const n) -> vctr1
        pow(vctr1 self, double n) -> vctr1
        """
        return _model.vctr1_pow(self, *args)

    def is_nan(self):
        """is_nan(vctr1 self) -> bool"""
        return _model.vctr1_is_nan(self)

    def is_bad(self):
        """is_bad(vctr1 self) -> bool"""
        return _model.vctr1_is_bad(self)

    def circ(self, *args):
        """circ(vctr1 self, int l) -> vctr1"""
        return _model.vctr1_circ(self, *args)

    def c_str(self, separator=" ", format="%g"):
        """
        c_str(vctr1 self, char const * separator=" ", char const * format="%g") -> char const
        c_str(vctr1 self, char const * separator=" ") -> char const
        c_str(vctr1 self) -> char const *
        """
        return _model.vctr1_c_str(self, separator, format)

    def __rmul__(self, *args):
        """
        __rmul__(vctr1 self, double x) -> vctr1
        __rmul__(vctr1 self, indx1 I) -> vctr1
        __rmul__(vctr1 self, PyObject * t) -> vctr1
        """
        return _model.vctr1___rmul__(self, *args)

    def __len__(self):
        """__len__(vctr1 self) -> int const"""
        return _model.vctr1___len__(self)

    def __getitem__(self, *args):
        """__getitem__(vctr1 self, int i) -> double"""
        return _model.vctr1___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(vctr1 self, int i, double x)"""
        return _model.vctr1___setitem__(self, *args)

    def __getslice__(self, *args):
        """__getslice__(vctr1 self, long a, long b) -> PyObject *"""
        return _model.vctr1___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(vctr1 self, long a, long b, PyObject * t)"""
        return _model.vctr1___setslice__(self, *args)

    def __str__(self):
        """__str__(vctr1 self) -> PyObject *"""
        return _model.vctr1___str__(self)

    def __repr__(self):
        """__repr__(vctr1 self) -> PyObject *"""
        return _model.vctr1___repr__(self)

    def __getstate__(self):
        """__getstate__(vctr1 self) -> PyObject *"""
        return _model.vctr1___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(vctr1 self, PyObject * t)"""
        return _model.vctr1___C_setstate__(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::vctr<(1,double)> self, double val=0) -> vctr1
        __init__(aiv::vctr<(1,double)> self) -> vctr1
        __init__(aiv::vctr<(1,double)> self, double const * Ap) -> vctr1
        __init__(aiv::vctr<(1,double)> self, vctr1 v) -> vctr1
        __init__(aiv::vctr<(1,double)> self, PyObject * t) -> vctr1
        """
        this = _model.new_vctr1(*args)
        try: self.this.append(this)
        except: self.this = this
    def __hash__(self):
        """__hash__(vctr1 self) -> long"""
        return _model.vctr1___hash__(self)

    def py_debug_info(self, *args):
        """py_debug_info(vctr1 self, aiv::debug_info & S)"""
        return _model.vctr1_py_debug_info(self, *args)

    __swig_destroy__ = _model.delete_vctr1
    __del__ = lambda self : None;
vctr1_swigregister = _model.vctr1_swigregister
vctr1_swigregister(vctr1)

def Vctr( *L ) : v = getattr( import_aivlib( 'vctr%i'%len(L) ), 'vctr%i'%len(L) )(); v[:] = tuple(L); return v
def _vctr1__xor__( a,b ) :  
  try : return Vctr(*map( float.__mul__, tuple(a),tuple(b) ) )  
  except : return  Vctr(*(tuple(a)[:b]+tuple(a)[b+1:]))
vctr1.__xor__ = _vctr1__xor__ 
vctr1.__or__ =lambda a,b : Vctr(*(tuple(a)+tuple(((b,),b)[b.__class__.__name__.startswith('vctr')])))  
vctr1.__ror__=lambda a,b : Vctr(*(tuple(((b,),b)[b.__class__.__name__.startswith('vctr')])+tuple(a)))  
vctr1.__setstate__ = _setstate 

class indx3(_object):
    """Proxy of C++ aiv::indx<(3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, indx3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, indx3, name)
    def volume(self):
        """volume(indx3 self) -> long"""
        return _model.indx3_volume(self)

    def __lt__(self, *args):
        """
        __lt__(indx3 self, indx3 r) -> bool
        __lt__(indx3 self, PyObject * t) -> bool
        __lt__(indx3 self, long i) -> bool
        """
        return _model.indx3___lt__(self, *args)

    def __le__(self, *args):
        """
        __le__(indx3 self, indx3 r) -> bool
        __le__(indx3 self, PyObject * t) -> bool
        __le__(indx3 self, long i) -> bool
        """
        return _model.indx3___le__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(indx3 self, indx3 r) -> bool
        __gt__(indx3 self, PyObject * t) -> bool
        __gt__(indx3 self, long i) -> bool
        """
        return _model.indx3___gt__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(indx3 self, indx3 r) -> bool
        __ge__(indx3 self, PyObject * t) -> bool
        __ge__(indx3 self, long i) -> bool
        """
        return _model.indx3___ge__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(indx3 self, indx3 r) -> bool
        __eq__(indx3 self, PyObject * t) -> bool
        __eq__(indx3 self, long i) -> bool
        """
        return _model.indx3___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(indx3 self, indx3 r) -> bool
        __ne__(indx3 self, PyObject * t) -> bool
        __ne__(indx3 self, long i) -> bool
        """
        return _model.indx3___ne__(self, *args)

    def __add__(self, *args):
        """
        __add__(indx3 self, indx3 r) -> indx3
        __add__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(indx3 self, indx3 r) -> indx3
        __sub__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___sub__(self, *args)

    def __xor__(self, *args):
        """
        __xor__(indx3 self, indx3 r) -> indx3
        __xor__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___xor__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(indx3 self, indx3 r) -> long
        __mul__(indx3 self, int j) -> indx3
        """
        return _model.indx3___mul__(self, *args)

    def __imul__(self, *args):
        """__imul__(indx3 self, int j) -> indx3"""
        return _model.indx3___imul__(self, *args)

    def __neg__(self):
        """__neg__(indx3 self) -> indx3"""
        return _model.indx3___neg__(self)

    def __ixor__(self, *args):
        """
        __ixor__(indx3 self, indx3 r) -> indx3
        __ixor__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___ixor__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(indx3 self, indx3 r) -> indx3
        __iadd__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(indx3 self, indx3 r) -> indx3
        __isub__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___isub__(self, *args)

    def __lshift__(self, *args):
        """
        __lshift__(indx3 self, indx3 b) -> indx3
        __lshift__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___lshift__(self, *args)

    def __rshift__(self, *args):
        """
        __rshift__(indx3 self, indx3 b) -> indx3
        __rshift__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___rshift__(self, *args)

    def __ilshift__(self, *args):
        """
        __ilshift__(indx3 self, indx3 b) -> indx3
        __ilshift__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___ilshift__(self, *args)

    def __irshift__(self, *args):
        """
        __irshift__(indx3 self, indx3 b) -> indx3
        __irshift__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___irshift__(self, *args)

    def __mod__(self, *args):
        """
        __mod__(indx3 self, indx3 b) -> indx3
        __mod__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___mod__(self, *args)

    def __imod__(self, *args):
        """
        __imod__(indx3 self, indx3 b) -> indx3
        __imod__(indx3 self, PyObject * t) -> indx3
        """
        return _model.indx3___imod__(self, *args)

    def __rmod__(self, *args):
        """__rmod__(indx3 self, long x) -> indx3"""
        return _model.indx3___rmod__(self, *args)

    def __div__(self, *args):
        """
        __div__(indx3 self, indx3 b) -> indx3
        __div__(indx3 self, PyObject * t) -> indx3
        __div__(indx3 self, int x) -> indx3
        """
        return _model.indx3___div__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(indx3 self, indx3 b) -> indx3
        __idiv__(indx3 self, PyObject * t) -> indx3
        __idiv__(indx3 self, int x) -> indx3
        """
        return _model.indx3___idiv__(self, *args)

    def circ(self, *args):
        """circ(indx3 self, int l) -> indx3"""
        return _model.indx3_circ(self, *args)

    def c_str(self, separator=" ", format="%i"):
        """
        c_str(indx3 self, char const * separator=" ", char const * format="%i") -> char const
        c_str(indx3 self, char const * separator=" ") -> char const
        c_str(indx3 self) -> char const *
        """
        return _model.indx3_c_str(self, separator, format)

    def __contains__(self, *args):
        """__contains__(indx3 self, indx3 I) -> bool"""
        return _model.indx3___contains__(self, *args)

    def __rmul__(self, *args):
        """__rmul__(indx3 self, int x) -> indx3"""
        return _model.indx3___rmul__(self, *args)

    def __len__(self):
        """__len__(indx3 self) -> int const"""
        return _model.indx3___len__(self)

    def __int__(self):
        """__int__(indx3 self) -> long"""
        return _model.indx3___int__(self)

    def __getitem__(self, *args):
        """__getitem__(indx3 self, int i) -> int"""
        return _model.indx3___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(indx3 self, int i, int x)"""
        return _model.indx3___setitem__(self, *args)

    def __getslice__(self, *args):
        """__getslice__(indx3 self, long a, long b) -> PyObject *"""
        return _model.indx3___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(indx3 self, long a, long b, PyObject * t)"""
        return _model.indx3___setslice__(self, *args)

    def __str__(self):
        """__str__(indx3 self) -> PyObject *"""
        return _model.indx3___str__(self)

    def __repr__(self):
        """__repr__(indx3 self) -> PyObject *"""
        return _model.indx3___repr__(self)

    def __getstate__(self):
        """__getstate__(indx3 self) -> PyObject *"""
        return _model.indx3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(indx3 self, PyObject * t)"""
        return _model.indx3___C_setstate__(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::indx<(3)> self, int val=0) -> indx3
        __init__(aiv::indx<(3)> self) -> indx3
        __init__(aiv::indx<(3)> self, int const * Ap) -> indx3
        __init__(aiv::indx<(3)> self, PyObject * t) -> indx3
        """
        this = _model.new_indx3(*args)
        try: self.this.append(this)
        except: self.this = this
    def __hash__(self):
        """__hash__(indx3 self) -> long"""
        return _model.indx3___hash__(self)

    def py_debug_info(self, *args):
        """py_debug_info(indx3 self, aiv::debug_info & S)"""
        return _model.indx3_py_debug_info(self, *args)

    def less(self, *args):
        """
        less(indx3 self, indx3 N) -> bool
        less(indx3 self, indx3 N, int const seq) -> bool
        """
        return _model.indx3_less(self, *args)

    def next(self, *args):
        """
        next(indx3 self, indx3 finish) -> bool
        next(indx3 self, indx3 start, indx3 finish) -> bool
        next(indx3 self, indx3 start, indx3 finish, int const seq, int const direct=0) -> bool
        next(indx3 self, indx3 start, indx3 finish, int const seq) -> bool
        next(indx3 self, indx3 finish, int const seq, int const direct=0) -> bool
        next(indx3 self, indx3 finish, int const seq) -> bool
        """
        return _model.indx3_next(self, *args)

    def z_next(self, *args):
        """
        z_next(indx3 self, int const rank) -> bool
        z_next(indx3 self, int const rank, int const seq) -> bool
        """
        return _model.indx3_z_next(self, *args)

    __swig_destroy__ = _model.delete_indx3
    __del__ = lambda self : None;
indx3_swigregister = _model.indx3_swigregister
indx3_swigregister(indx3)

def Indx( *L ) : v = getattr( import_aivlib( 'indx%i'%len(L) ), 'indx%i'%len(L) )(); v[:] = tuple(L); return v
indx3.__rcmp__=lambda a,b : -b.__cmp__(a) 
def _indx3__xor__( a,b ) :  
  try : return Indx(*map( int.__mul__, tuple(a),tuple(b) ) )  
  except : return  Indx(*(tuple(a)[:b]+tuple(a)[b+1:]))
indx3.__xor__ = _indx3__xor__ 
indx3.__or__ =lambda a,b : Indx(*(tuple(a)+tuple(((b,),b)[b.__class__.__name__.startswith('indx')])))  
indx3.__ror__=lambda a,b : Indx(*(tuple(((b,),b)[b.__class__.__name__.startswith('indx')])+tuple(a)))  
indx3.__setstate__ = _setstate 

class vctr3(_object):
    """Proxy of C++ aiv::vctr<(3,double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vctr3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vctr3, name)
    def __lt__(self, *args):
        """
        __lt__(vctr3 self, vctr3 r) -> bool
        __lt__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___lt__(self, *args)

    def __le__(self, *args):
        """
        __le__(vctr3 self, vctr3 r) -> bool
        __le__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___le__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(vctr3 self, vctr3 r) -> bool
        __gt__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___gt__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(vctr3 self, vctr3 r) -> bool
        __ge__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___ge__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(vctr3 self, vctr3 r) -> bool
        __eq__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(vctr3 self, vctr3 r) -> bool
        __ne__(vctr3 self, PyObject * t) -> bool
        """
        return _model.vctr3___ne__(self, *args)

    def __and__(self, *args):
        """
        __and__(vctr3 self, vctr3 r) -> double
        __and__(vctr3 self, PyObject * t) -> double
        """
        return _model.vctr3___and__(self, *args)

    def __add__(self, *args):
        """
        __add__(vctr3 self, vctr3 r) -> vctr3
        __add__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(vctr3 self, vctr3 r) -> vctr3
        __sub__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___sub__(self, *args)

    def __iadd__(self, *args):
        """
        __iadd__(vctr3 self, vctr3 r) -> vctr3
        __iadd__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___iadd__(self, *args)

    def __isub__(self, *args):
        """
        __isub__(vctr3 self, vctr3 r) -> vctr3
        __isub__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___isub__(self, *args)

    def __lshift__(self, *args):
        """
        __lshift__(vctr3 self, vctr3 r) -> vctr3
        __lshift__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___lshift__(self, *args)

    def __rshift__(self, *args):
        """
        __rshift__(vctr3 self, vctr3 r) -> vctr3
        __rshift__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___rshift__(self, *args)

    def __ilshift__(self, *args):
        """
        __ilshift__(vctr3 self, vctr3 r) -> vctr3
        __ilshift__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___ilshift__(self, *args)

    def __irshift__(self, *args):
        """
        __irshift__(vctr3 self, vctr3 r) -> vctr3
        __irshift__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___irshift__(self, *args)

    def __xor__(self, *args):
        """
        __xor__(vctr3 self, vctr3 r) -> vctr3
        __xor__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___xor__(self, *args)

    def __ixor__(self, *args):
        """
        __ixor__(vctr3 self, vctr3 r) -> vctr3
        __ixor__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___ixor__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(vctr3 self, vctr3 r) -> double
        __mul__(vctr3 self, indx3 I) -> vctr3
        __mul__(vctr3 self, PyObject * t) -> vctr3
        __mul__(vctr3 self, double x) -> vctr3
        """
        return _model.vctr3___mul__(self, *args)

    def __imul__(self, *args):
        """
        __imul__(vctr3 self, indx3 I) -> vctr3
        __imul__(vctr3 self, PyObject * t) -> vctr3
        __imul__(vctr3 self, double x) -> vctr3
        """
        return _model.vctr3___imul__(self, *args)

    def __div__(self, *args):
        """
        __div__(vctr3 self, vctr3 r) -> indx3
        __div__(vctr3 self, indx3 I) -> vctr3
        __div__(vctr3 self, PyObject * t) -> vctr3
        __div__(vctr3 self, double x) -> vctr3
        """
        return _model.vctr3___div__(self, *args)

    def __idiv__(self, *args):
        """
        __idiv__(vctr3 self, indx3 I) -> vctr3
        __idiv__(vctr3 self, PyObject * t) -> vctr3
        __idiv__(vctr3 self, double x) -> vctr3
        """
        return _model.vctr3___idiv__(self, *args)

    def __neg__(self):
        """__neg__(vctr3 self) -> vctr3"""
        return _model.vctr3___neg__(self)

    def abs(self):
        """abs(vctr3 self) -> double"""
        return _model.vctr3_abs(self)

    def pow(self, *args):
        """
        pow(vctr3 self, int const n) -> vctr3
        pow(vctr3 self, double n) -> vctr3
        """
        return _model.vctr3_pow(self, *args)

    def is_nan(self):
        """is_nan(vctr3 self) -> bool"""
        return _model.vctr3_is_nan(self)

    def is_bad(self):
        """is_bad(vctr3 self) -> bool"""
        return _model.vctr3_is_bad(self)

    def circ(self, *args):
        """circ(vctr3 self, int l) -> vctr3"""
        return _model.vctr3_circ(self, *args)

    def c_str(self, separator=" ", format="%g"):
        """
        c_str(vctr3 self, char const * separator=" ", char const * format="%g") -> char const
        c_str(vctr3 self, char const * separator=" ") -> char const
        c_str(vctr3 self) -> char const *
        """
        return _model.vctr3_c_str(self, separator, format)

    def __rmul__(self, *args):
        """
        __rmul__(vctr3 self, double x) -> vctr3
        __rmul__(vctr3 self, indx3 I) -> vctr3
        __rmul__(vctr3 self, PyObject * t) -> vctr3
        """
        return _model.vctr3___rmul__(self, *args)

    def __len__(self):
        """__len__(vctr3 self) -> int const"""
        return _model.vctr3___len__(self)

    def __getitem__(self, *args):
        """__getitem__(vctr3 self, int i) -> double"""
        return _model.vctr3___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(vctr3 self, int i, double x)"""
        return _model.vctr3___setitem__(self, *args)

    def __getslice__(self, *args):
        """__getslice__(vctr3 self, long a, long b) -> PyObject *"""
        return _model.vctr3___getslice__(self, *args)

    def __setslice__(self, *args):
        """__setslice__(vctr3 self, long a, long b, PyObject * t)"""
        return _model.vctr3___setslice__(self, *args)

    def __str__(self):
        """__str__(vctr3 self) -> PyObject *"""
        return _model.vctr3___str__(self)

    def __repr__(self):
        """__repr__(vctr3 self) -> PyObject *"""
        return _model.vctr3___repr__(self)

    def __getstate__(self):
        """__getstate__(vctr3 self) -> PyObject *"""
        return _model.vctr3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(vctr3 self, PyObject * t)"""
        return _model.vctr3___C_setstate__(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::vctr<(3,double)> self, double val=0) -> vctr3
        __init__(aiv::vctr<(3,double)> self) -> vctr3
        __init__(aiv::vctr<(3,double)> self, double const * Ap) -> vctr3
        __init__(aiv::vctr<(3,double)> self, vctr3 v) -> vctr3
        __init__(aiv::vctr<(3,double)> self, PyObject * t) -> vctr3
        """
        this = _model.new_vctr3(*args)
        try: self.this.append(this)
        except: self.this = this
    def __hash__(self):
        """__hash__(vctr3 self) -> long"""
        return _model.vctr3___hash__(self)

    def py_debug_info(self, *args):
        """py_debug_info(vctr3 self, aiv::debug_info & S)"""
        return _model.vctr3_py_debug_info(self, *args)

    __swig_destroy__ = _model.delete_vctr3
    __del__ = lambda self : None;
vctr3_swigregister = _model.vctr3_swigregister
vctr3_swigregister(vctr3)

vctr3.__mod__=lambda a,b : vctr3((a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0])) 
def Vctr( *L ) : v = getattr( import_aivlib( 'vctr%i'%len(L) ), 'vctr%i'%len(L) )(); v[:] = tuple(L); return v
def _vctr3__xor__( a,b ) :  
  try : return Vctr(*map( float.__mul__, tuple(a),tuple(b) ) )  
  except : return  Vctr(*(tuple(a)[:b]+tuple(a)[b+1:]))
vctr3.__xor__ = _vctr3__xor__ 
vctr3.__or__ =lambda a,b : Vctr(*(tuple(a)+tuple(((b,),b)[b.__class__.__name__.startswith('vctr')])))  
vctr3.__ror__=lambda a,b : Vctr(*(tuple(((b,),b)[b.__class__.__name__.startswith('vctr')])+tuple(a)))  
vctr3.__setstate__ = _setstate 


def angle(*args):
  """
    angle(vctr1 a, vctr1 b, vctr1 c) -> double
    angle(vctr3 a, vctr3 b, vctr3 c) -> double
    """
  return _model.angle(*args)
class arrPT3(_object):
    """Proxy of C++ aiv::array<(p.Base_tile,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, arrPT3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, arrPT3, name)
    __repr__ = _swig_repr
    dim = _model.arrPT3_dim
    dump_dim = _model.arrPT3_dump_dim
    __swig_getmethods__["N"] = _model.arrPT3_N_get
    if _newclass:N = _swig_property(_model.arrPT3_N_get)
    def clean(self):
        """clean(arrPT3 self)"""
        return _model.arrPT3_clean(self)

    def init(self, *args):
        """init(arrPT3 self, indx3 AN)"""
        return _model.arrPT3_init(self, *args)

    def mmap(self, *args):
        """
        mmap(arrPT3 self, indx3 AN, char const * fname, long offset, bool write=False)
        mmap(arrPT3 self, indx3 AN, char const * fname, long offset)
        """
        return _model.arrPT3_mmap(self, *args)

    def info(self, *args):
        """
        info(arrPT3 self, aiv::Ostream & S=mystdout)
        info(arrPT3 self)
        """
        return _model.arrPT3_info(self, *args)

    def solid_dims(self):
        """solid_dims(arrPT3 self) -> int"""
        return _model.arrPT3_solid_dims(self)

    def nb_shift(self, *args):
        """nb_shift(arrPT3 self, int pos, int axe) -> long"""
        return _model.arrPT3_nb_shift(self, *args)

    def index(self, *args):
        """
        index(arrPT3 self, indx3 I) -> long
        index(arrPT3 self, long i) -> long
        """
        return _model.arrPT3_index(self, *args)

    def get(self, *args):
        """
        get(arrPT3 self, long i) -> Base_tile
        get(arrPT3 self, long i) -> Base_tile *&
        """
        return _model.arrPT3_get(self, *args)

    __swig_destroy__ = _model.delete_arrPT3
    __del__ = lambda self : None;
    def copy(self):
        """copy(arrPT3 self) -> arrPT3"""
        return _model.arrPT3_copy(self)

    def crop(self, *args):
        """
        crop(arrPT3 self, indx3 a, indx3 b, indx3 step=aiv::indx(1)) -> arrPT3
        crop(arrPT3 self, indx3 a, indx3 b) -> arrPT3
        """
        return _model.arrPT3_crop(self, *args)

    def swap(self, *args):
        """swap(arrPT3 self, int i, int j) -> arrPT3"""
        return _model.arrPT3_swap(self, *args)

    def flip(self, *args):
        """flip(arrPT3 self, int i) -> arrPT3"""
        return _model.arrPT3_flip(self, *args)

    def __len__(self):
        """__len__(arrPT3 self) -> int"""
        return _model.arrPT3___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(arrPT3 self, indx3 I) -> Base_tile
        __getitem__(arrPT3 self, long I) -> Base_tile
        __getitem__(arrPT3 self, PyObject * t) -> Base_tile *&
        """
        return _model.arrPT3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(arrPT3 self, indx3 I, Base_tile val)
        __setitem__(arrPT3 self, long I, Base_tile val)
        __setitem__(arrPT3 self, PyObject * t, Base_tile val)
        """
        return _model.arrPT3___setitem__(self, *args)

    def __getstate__(self):
        """__getstate__(arrPT3 self) -> PyObject *"""
        return _model.arrPT3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(arrPT3 self, PyObject * t)"""
        return _model.arrPT3___C_setstate__(self, *args)

    def dump(self, *args):
        """
        dump(arrPT3 self, aiv::Ostream & S, char const * header=None)
        dump(arrPT3 self, aiv::Ostream & S)
        """
        return _model.arrPT3_dump(self, *args)

    def update(self, *args):
        """
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *), long shift_in=-1) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *)) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1)) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx()) -> indx3
        update(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx()) -> indx3
        update(arrPT3 self, aiv::Istream & S) -> indx3
        update(arrPT3 self, arrPT3 A) -> indx3
        """
        return _model.arrPT3_update(self, *args)

    def load(self, *args):
        """
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *), long shift_in=-1)
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *))
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3)
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None)
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1))
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx())
        load(arrPT3 self, aiv::Istream & S, indx3 a=aiv::indx())
        load(arrPT3 self, aiv::Istream & S)
        load(arrPT3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1, bool write=False)
        load(arrPT3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1)
        load(arrPT3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None)
        load(arrPT3 self, char const * fname, int D2=3, int axe=3-1)
        load(arrPT3 self, char const * fname, int D2=3)
        load(arrPT3 self, char const * fname)
        """
        return _model.arrPT3_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::array<(p.Base_tile,3)> self) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, indx3 AN) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, indx3 AN, Base_tile *const * Ap) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, arrPT3 A) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, indx3 AN, char const * fname, int offset, bool write=False) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, indx3 AN, char const * fname, int offset) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *), long shift_in=-1) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *)) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1)) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx()) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S, indx3 a=aiv::indx()) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, aiv::Istream & S) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1, bool write=False) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname, int D2=3, int axe=3-1) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname, int D2=3) -> arrPT3
        __init__(aiv::array<(p.Base_tile,3)> self, char const * fname) -> arrPT3
        """
        this = _model.new_arrPT3(*args)
        try: self.this.append(this)
        except: self.this = this
    def py_debug_info(self, *args):
        """py_debug_info(arrPT3 self, aiv::debug_info & S)"""
        return _model.arrPT3_py_debug_info(self, *args)

arrPT3_swigregister = _model.arrPT3_swigregister
arrPT3_swigregister(arrPT3)

class meshPT3(arrPT3):
    """Proxy of C++ aiv::mesh<(p.Base_tile,3)> class"""
    __swig_setmethods__ = {}
    for _s in [arrPT3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, meshPT3, name, value)
    __swig_getmethods__ = {}
    for _s in [arrPT3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, meshPT3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min"] = _model.meshPT3_min_set
    __swig_getmethods__["min"] = _model.meshPT3_min_get
    if _newclass:min = _swig_property(_model.meshPT3_min_get, _model.meshPT3_min_set)
    __swig_setmethods__["max"] = _model.meshPT3_max_set
    __swig_getmethods__["max"] = _model.meshPT3_max_get
    if _newclass:max = _swig_property(_model.meshPT3_max_get, _model.meshPT3_max_set)
    __swig_setmethods__["step"] = _model.meshPT3_step_set
    __swig_getmethods__["step"] = _model.meshPT3_step_get
    if _newclass:step = _swig_property(_model.meshPT3_step_get, _model.meshPT3_step_set)
    __swig_setmethods__["ext_val"] = _model.meshPT3_ext_val_set
    __swig_getmethods__["ext_val"] = _model.meshPT3_ext_val_get
    if _newclass:ext_val = _swig_property(_model.meshPT3_ext_val_get, _model.meshPT3_ext_val_set)
    def info(self, *args):
        """
        info(meshPT3 self, aiv::Ostream & S=mystdout)
        info(meshPT3 self)
        """
        return _model.meshPT3_info(self, *args)

    def copy(self):
        """copy(meshPT3 self) -> meshPT3"""
        return _model.meshPT3_copy(self)

    def crop(self, *args):
        """
        crop(meshPT3 self, indx3 a, indx3 b, indx3 istep=aiv::indx(1)) -> meshPT3
        crop(meshPT3 self, indx3 a, indx3 b) -> meshPT3
        crop(meshPT3 self, vctr3 a, vctr3 b, indx3 istep=aiv::indx(1)) -> meshPT3
        crop(meshPT3 self, vctr3 a, vctr3 b) -> meshPT3
        """
        return _model.meshPT3_crop(self, *args)

    def swap(self, *args):
        """swap(meshPT3 self, int i, int j) -> meshPT3"""
        return _model.meshPT3_swap(self, *args)

    def flip(self, *args):
        """flip(meshPT3 self, int i) -> meshPT3"""
        return _model.meshPT3_flip(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(meshPT3 self, long i) -> Base_tile
        __getitem__(meshPT3 self, indx3 I) -> Base_tile
        __getitem__(meshPT3 self, PyObject * t) -> Base_tile
        __getitem__(meshPT3 self, vctr3 r) -> Base_tile *&
        """
        return _model.meshPT3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(meshPT3 self, long i, Base_tile v)
        __setitem__(meshPT3 self, indx3 I, Base_tile v)
        __setitem__(meshPT3 self, PyObject * t, Base_tile val)
        __setitem__(meshPT3 self, vctr3 r, Base_tile v)
        """
        return _model.meshPT3___setitem__(self, *args)

    def __contains__(self, *args):
        """__contains__(meshPT3 self, vctr3 r) -> bool"""
        return _model.meshPT3___contains__(self, *args)

    def __getstate__(self):
        """__getstate__(meshPT3 self) -> PyObject *"""
        return _model.meshPT3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(meshPT3 self, PyObject * t)"""
        return _model.meshPT3___C_setstate__(self, *args)

    def dump(self, *args):
        """
        dump(meshPT3 self, aiv::Ostream & S, char const * head=None)
        dump(meshPT3 self, aiv::Ostream & S)
        """
        return _model.meshPT3_dump(self, *args)

    def load(self, *args):
        """
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *), long shift_in=-1)
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_tile *))
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3)
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None)
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1))
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx())
        load(meshPT3 self, aiv::Istream & S, indx3 a=aiv::indx())
        load(meshPT3 self, aiv::Istream & S)
        """
        return _model.meshPT3_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::mesh<(p.Base_tile,3)> self) -> meshPT3
        __init__(aiv::mesh<(p.Base_tile,3)> self, indx3 AN) -> meshPT3
        __init__(aiv::mesh<(p.Base_tile,3)> self, indx3 AN, vctr3 Amin, vctr3 Amax, Base_tile *const * Ap) -> meshPT3
        __init__(aiv::mesh<(p.Base_tile,3)> self, meshPT3 M) -> meshPT3
        __init__(aiv::mesh<(p.Base_tile,3)> self, arrPT3 A) -> meshPT3
        __init__(aiv::mesh<(p.Base_tile,3)> self, aiv::Istream & S) -> meshPT3
        """
        this = _model.new_meshPT3(*args)
        try: self.this.append(this)
        except: self.this = this
    def py_debug_info(self, *args):
        """py_debug_info(meshPT3 self, aiv::debug_info & S)"""
        return _model.meshPT3_py_debug_info(self, *args)

    __swig_destroy__ = _model.delete_meshPT3
    __del__ = lambda self : None;
meshPT3_swigregister = _model.meshPT3_swigregister
meshPT3_swigregister(meshPT3)

class mult_arrPT3(_object):
    """Proxy of C++ aiv::multiarray<(aiv::array<(ptile,3)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mult_arrPT3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mult_arrPT3, name)
    __repr__ = _swig_repr
    dim = _model.mult_arrPT3_dim
    __swig_setmethods__["N"] = _model.mult_arrPT3_N_set
    __swig_getmethods__["N"] = _model.mult_arrPT3_N_get
    if _newclass:N = _swig_property(_model.mult_arrPT3_N_get, _model.mult_arrPT3_N_set)
    __swig_setmethods__["ext_val"] = _model.mult_arrPT3_ext_val_set
    __swig_getmethods__["ext_val"] = _model.mult_arrPT3_ext_val_get
    if _newclass:ext_val = _swig_property(_model.mult_arrPT3_ext_val_get, _model.mult_arrPT3_ext_val_set)
    def __init__(self): 
        """__init__(aiv::multiarray<(aiv::array<(ptile,3)>)> self) -> mult_arrPT3"""
        this = _model.new_mult_arrPT3()
        try: self.this.append(this)
        except: self.this = this
    def add_arr(self, *args):
        """add_arr(mult_arrPT3 self, indx3 offset, arrPT3 arr)"""
        return _model.mult_arrPT3_add_arr(self, *args)

    def dump(self, *args):
        """
        dump(mult_arrPT3 self, aiv::Ostream & S, char const * header=None)
        dump(mult_arrPT3 self, aiv::Ostream & S)
        """
        return _model.mult_arrPT3_dump(self, *args)

    def load(self, *args):
        """load(mult_arrPT3 self, aiv::Istream & S)"""
        return _model.mult_arrPT3_load(self, *args)

    def __len__(self):
        """__len__(mult_arrPT3 self) -> int"""
        return _model.mult_arrPT3___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(mult_arrPT3 self, indx3 I) -> Base_tile
        __getitem__(mult_arrPT3 self, long I) -> aiv::multiarray< aiv::array< Base_tile *,3 > >::cell_type &
        """
        return _model.mult_arrPT3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(mult_arrPT3 self, indx3 I, aiv::multiarray< aiv::array< Base_tile *,3 > >::cell_type & val)
        __setitem__(mult_arrPT3 self, long I, aiv::multiarray< aiv::array< Base_tile *,3 > >::cell_type & val)
        """
        return _model.mult_arrPT3___setitem__(self, *args)

    __swig_destroy__ = _model.delete_mult_arrPT3
    __del__ = lambda self : None;
mult_arrPT3_swigregister = _model.mult_arrPT3_swigregister
mult_arrPT3_swigregister(mult_arrPT3)

arrPT3.__setstate__, meshPT3.__setstate__ = _setstate, _setstate 
from aivlib.vctr3 import * 
from aivlib.mystream import * 
class arrPC3(_object):
    """Proxy of C++ aiv::array<(p.Base_cell,3)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, arrPC3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, arrPC3, name)
    __repr__ = _swig_repr
    dim = _model.arrPC3_dim
    dump_dim = _model.arrPC3_dump_dim
    __swig_getmethods__["N"] = _model.arrPC3_N_get
    if _newclass:N = _swig_property(_model.arrPC3_N_get)
    def clean(self):
        """clean(arrPC3 self)"""
        return _model.arrPC3_clean(self)

    def init(self, *args):
        """init(arrPC3 self, indx3 AN)"""
        return _model.arrPC3_init(self, *args)

    def mmap(self, *args):
        """
        mmap(arrPC3 self, indx3 AN, char const * fname, long offset, bool write=False)
        mmap(arrPC3 self, indx3 AN, char const * fname, long offset)
        """
        return _model.arrPC3_mmap(self, *args)

    def info(self, *args):
        """
        info(arrPC3 self, aiv::Ostream & S=mystdout)
        info(arrPC3 self)
        """
        return _model.arrPC3_info(self, *args)

    def solid_dims(self):
        """solid_dims(arrPC3 self) -> int"""
        return _model.arrPC3_solid_dims(self)

    def nb_shift(self, *args):
        """nb_shift(arrPC3 self, int pos, int axe) -> long"""
        return _model.arrPC3_nb_shift(self, *args)

    def index(self, *args):
        """
        index(arrPC3 self, indx3 I) -> long
        index(arrPC3 self, long i) -> long
        """
        return _model.arrPC3_index(self, *args)

    def get(self, *args):
        """
        get(arrPC3 self, long i) -> Base_cell
        get(arrPC3 self, long i) -> Base_cell *&
        """
        return _model.arrPC3_get(self, *args)

    __swig_destroy__ = _model.delete_arrPC3
    __del__ = lambda self : None;
    def copy(self):
        """copy(arrPC3 self) -> arrPC3"""
        return _model.arrPC3_copy(self)

    def crop(self, *args):
        """
        crop(arrPC3 self, indx3 a, indx3 b, indx3 step=aiv::indx(1)) -> arrPC3
        crop(arrPC3 self, indx3 a, indx3 b) -> arrPC3
        """
        return _model.arrPC3_crop(self, *args)

    def swap(self, *args):
        """swap(arrPC3 self, int i, int j) -> arrPC3"""
        return _model.arrPC3_swap(self, *args)

    def flip(self, *args):
        """flip(arrPC3 self, int i) -> arrPC3"""
        return _model.arrPC3_flip(self, *args)

    def __len__(self):
        """__len__(arrPC3 self) -> int"""
        return _model.arrPC3___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(arrPC3 self, indx3 I) -> Base_cell
        __getitem__(arrPC3 self, long I) -> Base_cell
        __getitem__(arrPC3 self, PyObject * t) -> Base_cell *&
        """
        return _model.arrPC3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(arrPC3 self, indx3 I, Base_cell val)
        __setitem__(arrPC3 self, long I, Base_cell val)
        __setitem__(arrPC3 self, PyObject * t, Base_cell val)
        """
        return _model.arrPC3___setitem__(self, *args)

    def __getstate__(self):
        """__getstate__(arrPC3 self) -> PyObject *"""
        return _model.arrPC3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(arrPC3 self, PyObject * t)"""
        return _model.arrPC3___C_setstate__(self, *args)

    def dump(self, *args):
        """
        dump(arrPC3 self, aiv::Ostream & S, char const * header=None)
        dump(arrPC3 self, aiv::Ostream & S)
        """
        return _model.arrPC3_dump(self, *args)

    def update(self, *args):
        """
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *), long shift_in=-1) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *)) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1)) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx()) -> indx3
        update(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx()) -> indx3
        update(arrPC3 self, aiv::Istream & S) -> indx3
        update(arrPC3 self, arrPC3 A) -> indx3
        """
        return _model.arrPC3_update(self, *args)

    def load(self, *args):
        """
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *), long shift_in=-1)
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *))
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3)
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None)
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1))
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx())
        load(arrPC3 self, aiv::Istream & S, indx3 a=aiv::indx())
        load(arrPC3 self, aiv::Istream & S)
        load(arrPC3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1, bool write=False)
        load(arrPC3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1)
        load(arrPC3 self, char const * fname, int D2=3, int axe=3-1, int * offset=None)
        load(arrPC3 self, char const * fname, int D2=3, int axe=3-1)
        load(arrPC3 self, char const * fname, int D2=3)
        load(arrPC3 self, char const * fname)
        """
        return _model.arrPC3_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::array<(p.Base_cell,3)> self) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, indx3 AN) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, indx3 AN, Base_cell *const * Ap) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, arrPC3 A) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, indx3 AN, char const * fname, int offset, bool write=False) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, indx3 AN, char const * fname, int offset) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *), long shift_in=-1) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *)) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1)) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx()) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S, indx3 a=aiv::indx()) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, aiv::Istream & S) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1, bool write=False) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None, int max=-1) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname, int D2=3, int axe=3-1, int * offset=None) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname, int D2=3, int axe=3-1) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname, int D2=3) -> arrPC3
        __init__(aiv::array<(p.Base_cell,3)> self, char const * fname) -> arrPC3
        """
        this = _model.new_arrPC3(*args)
        try: self.this.append(this)
        except: self.this = this
    def py_debug_info(self, *args):
        """py_debug_info(arrPC3 self, aiv::debug_info & S)"""
        return _model.arrPC3_py_debug_info(self, *args)

arrPC3_swigregister = _model.arrPC3_swigregister
arrPC3_swigregister(arrPC3)

class meshPC3(arrPC3):
    """Proxy of C++ aiv::mesh<(p.Base_cell,3)> class"""
    __swig_setmethods__ = {}
    for _s in [arrPC3]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, meshPC3, name, value)
    __swig_getmethods__ = {}
    for _s in [arrPC3]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, meshPC3, name)
    __repr__ = _swig_repr
    __swig_setmethods__["min"] = _model.meshPC3_min_set
    __swig_getmethods__["min"] = _model.meshPC3_min_get
    if _newclass:min = _swig_property(_model.meshPC3_min_get, _model.meshPC3_min_set)
    __swig_setmethods__["max"] = _model.meshPC3_max_set
    __swig_getmethods__["max"] = _model.meshPC3_max_get
    if _newclass:max = _swig_property(_model.meshPC3_max_get, _model.meshPC3_max_set)
    __swig_setmethods__["step"] = _model.meshPC3_step_set
    __swig_getmethods__["step"] = _model.meshPC3_step_get
    if _newclass:step = _swig_property(_model.meshPC3_step_get, _model.meshPC3_step_set)
    __swig_setmethods__["ext_val"] = _model.meshPC3_ext_val_set
    __swig_getmethods__["ext_val"] = _model.meshPC3_ext_val_get
    if _newclass:ext_val = _swig_property(_model.meshPC3_ext_val_get, _model.meshPC3_ext_val_set)
    def info(self, *args):
        """
        info(meshPC3 self, aiv::Ostream & S=mystdout)
        info(meshPC3 self)
        """
        return _model.meshPC3_info(self, *args)

    def copy(self):
        """copy(meshPC3 self) -> meshPC3"""
        return _model.meshPC3_copy(self)

    def crop(self, *args):
        """
        crop(meshPC3 self, indx3 a, indx3 b, indx3 istep=aiv::indx(1)) -> meshPC3
        crop(meshPC3 self, indx3 a, indx3 b) -> meshPC3
        crop(meshPC3 self, vctr3 a, vctr3 b, indx3 istep=aiv::indx(1)) -> meshPC3
        crop(meshPC3 self, vctr3 a, vctr3 b) -> meshPC3
        """
        return _model.meshPC3_crop(self, *args)

    def swap(self, *args):
        """swap(meshPC3 self, int i, int j) -> meshPC3"""
        return _model.meshPC3_swap(self, *args)

    def flip(self, *args):
        """flip(meshPC3 self, int i) -> meshPC3"""
        return _model.meshPC3_flip(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(meshPC3 self, long i) -> Base_cell
        __getitem__(meshPC3 self, indx3 I) -> Base_cell
        __getitem__(meshPC3 self, PyObject * t) -> Base_cell
        __getitem__(meshPC3 self, vctr3 r) -> Base_cell *&
        """
        return _model.meshPC3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(meshPC3 self, long i, Base_cell v)
        __setitem__(meshPC3 self, indx3 I, Base_cell v)
        __setitem__(meshPC3 self, PyObject * t, Base_cell val)
        __setitem__(meshPC3 self, vctr3 r, Base_cell v)
        """
        return _model.meshPC3___setitem__(self, *args)

    def __contains__(self, *args):
        """__contains__(meshPC3 self, vctr3 r) -> bool"""
        return _model.meshPC3___contains__(self, *args)

    def __getstate__(self):
        """__getstate__(meshPC3 self) -> PyObject *"""
        return _model.meshPC3___getstate__(self)

    def __C_setstate__(self, *args):
        """__C_setstate__(meshPC3 self, PyObject * t)"""
        return _model.meshPC3___C_setstate__(self, *args)

    def dump(self, *args):
        """
        dump(meshPC3 self, aiv::Ostream & S, char const * head=None)
        dump(meshPC3 self, aiv::Ostream & S)
        """
        return _model.meshPC3_dump(self, *args)

    def load(self, *args):
        """
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *), long shift_in=-1)
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3, int szT=sizeof(Base_cell *))
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None, int D2=3)
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1), 
            int * pos=None)
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx(), indx3 step=aiv::indx(1))
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx(), indx3 b=aiv::indx())
        load(meshPC3 self, aiv::Istream & S, indx3 a=aiv::indx())
        load(meshPC3 self, aiv::Istream & S)
        """
        return _model.meshPC3_load(self, *args)

    def __init__(self, *args): 
        """
        __init__(aiv::mesh<(p.Base_cell,3)> self) -> meshPC3
        __init__(aiv::mesh<(p.Base_cell,3)> self, indx3 AN) -> meshPC3
        __init__(aiv::mesh<(p.Base_cell,3)> self, indx3 AN, vctr3 Amin, vctr3 Amax, Base_cell *const * Ap) -> meshPC3
        __init__(aiv::mesh<(p.Base_cell,3)> self, meshPC3 M) -> meshPC3
        __init__(aiv::mesh<(p.Base_cell,3)> self, arrPC3 A) -> meshPC3
        __init__(aiv::mesh<(p.Base_cell,3)> self, aiv::Istream & S) -> meshPC3
        """
        this = _model.new_meshPC3(*args)
        try: self.this.append(this)
        except: self.this = this
    def py_debug_info(self, *args):
        """py_debug_info(meshPC3 self, aiv::debug_info & S)"""
        return _model.meshPC3_py_debug_info(self, *args)

    __swig_destroy__ = _model.delete_meshPC3
    __del__ = lambda self : None;
meshPC3_swigregister = _model.meshPC3_swigregister
meshPC3_swigregister(meshPC3)

class mult_arrPC3(_object):
    """Proxy of C++ aiv::multiarray<(aiv::array<(pcell,3)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, mult_arrPC3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, mult_arrPC3, name)
    __repr__ = _swig_repr
    dim = _model.mult_arrPC3_dim
    __swig_setmethods__["N"] = _model.mult_arrPC3_N_set
    __swig_getmethods__["N"] = _model.mult_arrPC3_N_get
    if _newclass:N = _swig_property(_model.mult_arrPC3_N_get, _model.mult_arrPC3_N_set)
    __swig_setmethods__["ext_val"] = _model.mult_arrPC3_ext_val_set
    __swig_getmethods__["ext_val"] = _model.mult_arrPC3_ext_val_get
    if _newclass:ext_val = _swig_property(_model.mult_arrPC3_ext_val_get, _model.mult_arrPC3_ext_val_set)
    def __init__(self): 
        """__init__(aiv::multiarray<(aiv::array<(pcell,3)>)> self) -> mult_arrPC3"""
        this = _model.new_mult_arrPC3()
        try: self.this.append(this)
        except: self.this = this
    def add_arr(self, *args):
        """add_arr(mult_arrPC3 self, indx3 offset, arrPC3 arr)"""
        return _model.mult_arrPC3_add_arr(self, *args)

    def dump(self, *args):
        """
        dump(mult_arrPC3 self, aiv::Ostream & S, char const * header=None)
        dump(mult_arrPC3 self, aiv::Ostream & S)
        """
        return _model.mult_arrPC3_dump(self, *args)

    def load(self, *args):
        """load(mult_arrPC3 self, aiv::Istream & S)"""
        return _model.mult_arrPC3_load(self, *args)

    def __len__(self):
        """__len__(mult_arrPC3 self) -> int"""
        return _model.mult_arrPC3___len__(self)

    def __getitem__(self, *args):
        """
        __getitem__(mult_arrPC3 self, indx3 I) -> Base_cell
        __getitem__(mult_arrPC3 self, long I) -> aiv::multiarray< aiv::array< Base_cell *,3 > >::cell_type &
        """
        return _model.mult_arrPC3___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(mult_arrPC3 self, indx3 I, aiv::multiarray< aiv::array< Base_cell *,3 > >::cell_type & val)
        __setitem__(mult_arrPC3 self, long I, aiv::multiarray< aiv::array< Base_cell *,3 > >::cell_type & val)
        """
        return _model.mult_arrPC3___setitem__(self, *args)

    __swig_destroy__ = _model.delete_mult_arrPC3
    __del__ = lambda self : None;
mult_arrPC3_swigregister = _model.mult_arrPC3_swigregister
mult_arrPC3_swigregister(mult_arrPC3)

arrPC3.__setstate__, meshPC3.__setstate__ = _setstate, _setstate 

def splice1(*args):
  """
    splice1(arrPT3 A, indx3 pos) -> aiv::array< Base_tile *,1 >
    splice1(meshPT3 A, indx3 pos) -> aiv::mesh< Base_tile *,1 >
    splice1(arrPC3 A, indx3 pos) -> aiv::array< Base_cell *,1 >
    splice1(meshPC3 A, indx3 pos) -> aiv::mesh< Base_cell *,1 >
    """
  return _model.splice1(*args)

def splice2(*args):
  """
    splice2(arrPT3 A, indx3 pos) -> aiv::array< Base_tile *,2 >
    splice2(meshPT3 A, indx3 pos) -> aiv::mesh< Base_tile *,2 >
    splice2(arrPC3 A, indx3 pos) -> aiv::array< Base_cell *,2 >
    splice2(meshPC3 A, indx3 pos) -> aiv::mesh< Base_cell *,2 >
    """
  return _model.splice2(*args)
from aivlib.vctr3 import * 
from aivlib.mystream import * 
from aivlib.mystream import *; 
# This file is compatible with both classic and new-style classes.


